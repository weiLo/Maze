from queue import *
from array import array


class MickeyMove():
    def __init__(self, map,x_start , y_start):
        print("create mickey maze")
        self.x_start = x_start
        self.y_start = y_start
        self.path = Queue(maxsize=0)
        self.maze_map = map
    
    @classmethod
    def checkMove(self, x_nextPos, y_nextPos):
        maze = self.maze_map
        ch_lis = []
        N = x_nextPos+1,y_nextPos
        S = x_nextPos-1,y_nextPos
        E = x_nextPos,y_nextPos+1
        W = x_nextPos,y_nextPos-1
        if maze[x_nextPos+1][y_nextPos] == 0:
            ch_lis.append(N)
        if maze[x_nextPos-1][y_nextPos] == 0:
            ch_lis.append(S)
        if maze[x_nextPos][y_nextPos+1] == 0:
            ch_lis.append(E)
        if maze[x_nextPos][y_nextPos-1] == 0:
            ch_lis.append(W)
        return ch_lis
    
    @classmethod
    def checkFork(self,x_fork,y_fork):
        maze = self.maze_map
        if maze[x_fork][y_fork] == 0:
            return True
        else:
            return False 
        
    @classmethod    
    def getMaze(self,val):
        self.maze_map = val
    
    @classmethod
    def getPath(self):
        self.path = Queue(maxsize = 0)
        
    @classmethod
    def move(self, x_move, y_move):
        maze = self.maze_map
        path = self.getPath()
        print("\n")
        i = x_move
        j = y_move
        maze[i][j] = 1
        if self.checkMove(i,j) == True:

        elif self.checkMove(i,j) == False:
    
    @classmethod
    def choose(self,i,j):
        maze = self.maze_map
        if self.checkMove(i,j) == True:
            ran = list(range(4))
            ran[0] = (i+1,j)
            ran[1] = (i-1,j)
            ran[2] = (i,j+1)
            ran[3] = (i,j-1)
            nexM = self.random(ran)
            if self.checkMove(nexM[0],nexM[1]) == True:
                self.recStep(nexM[0],nexM[1])
            else:
                print("\n")

    @classmethod
    def recStep(self,x_recstep,y_recstep):
        array = []
        array.append([(x_recstep,y_recstep),self.checkMove(x_recstep,y_recstep),self.choose(x_recstep,y_recstep)])
        path.put(array)
    
    @classmethod
    def choose(self,x_fork,y_fork):
        ways = self.checkMove(x_fork,y_fork)
        choosefork= self.random(ways)
        return choosefork
        
    def setMaze(self,maze):
        self.maze_map = maze
        
    @classmethod
    def random(self,a):
        from random import choice
        return choice(a)
    
    @classmethod
    def checkGoal(self,x_goal,y_goal):
        maze = self.maze_map
        x_Mazeboun = len(maze[0])
        y_Mazeboun = len(maze)
        if maze[x_goal][y_Mazeboun-1] == 0 or maze[x_goal][0] ==0 or maze[0][y_goal] == 0 or maze[x_Mazeboun-1][y_goal] == 0:
            return True
        else:
            return False
        
    @classmethod
    def printMaze(self, maze_map):
        print("in maze")
        for row in maze_map:
            for val in row:
                print(val,end=" ")
            print(end="\n")

    

def main():
    maze =[
           [2, 2, 2, 2, 2, 2, 2],
           [2, 0, 0, 0, 0, 0, 2],
           [2, 0, 2, 0, 2, 0, 2],
           [2, 0, 0, 0, 0, 2, 2],
           [2, 2, 0, 2, 0, 2, 2],
           [2, 0, 0, 0, 0, 0, 0],
           [2, 2, 2, 2, 2, 2, 2]]

    m = MickeyMove(maze, 1,1)
    #print(m.maze_map)
    #m.printMaze(m.maze_map)
    m.getMaze(maze)
    m.move(1,1)
                
    
if __name__ == "__main__":
    main()
