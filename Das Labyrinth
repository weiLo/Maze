from queue import *
from array import array
path = Queue(maxsize = 0)
realpath = []
class MickeyMove():
    def __init__(self, map,x_start , y_start):
        print("create mickey maze")
        self.x_start = x_start
        self.y_start = y_start
        self.path = Queue(maxsize=0)
        self.maze_map = map
    
    @classmethod
    def checkMove(self, x_nextPos, y_nextPos):
        maze = self.maze_map
        ch_lis = []
        N = x_nextPos+1,y_nextPos
        S = x_nextPos-1,y_nextPos
        E = x_nextPos,y_nextPos+1
        W = x_nextPos,y_nextPos-1
        if maze[x_nextPos+1][y_nextPos] == 0:
            ch_lis.append(N)
        if maze[x_nextPos-1][y_nextPos] == 0:
            ch_lis.append(S)
        if maze[x_nextPos][y_nextPos+1] == 0:
            ch_lis.append(E)
        if maze[x_nextPos][y_nextPos-1] == 0:
            ch_lis.append(W)
        return ch_lis
    
        @classmethod
    def checkDeadend(self,xy_move):
        maze = self.maze_map
        dead_list = []
        x_dead = xy_move[0]
        y_dead = xy_move[1]
        N = x_dead+1,y_dead
        S = x_dead-1,y_dead
        E = x_dead,y_dead+1
        W = x_dead,y_dead-1
        if maze[x_dead+1][y_dead] == 2:
            dead_list.append(2)
        if maze[x_dead-1][y_dead] == 2:
            dead_list.append(2)
        if maze[x_dead][y_dead+1] == 2:
            dead_list.append(2)
        if maze[x_dead][y_dead-1] == 2:
            dead_list.append(2)
        if dead_list.count(2) >= 3:
            back = path.get()
            laststep = back[0]
            self.move(laststep[0],laststep[1])
        else:
            return
            
    @classmethod
    def checkFork(self,x_fork,y_fork):
        maze = self.maze_map
        if maze[x_fork][y_fork] == 0:
            return True
        else:
            return False 
        
    @classmethod    
    def getMaze(self,val):
        self.maze_map = val
    
    @classmethod
    def getPath(self):
        self.path = Queue(maxsize = 0)
        
    @classmethod
    def move(self, x_move, y_move):
        #print(x_move, y_move)
        maze = self.maze_map
        go = self.choose(x_move,y_move)
        self.checkDeadend(go)
        print("go:",go)
        self.recStep(x_move,y_move,go)
        self.actStep(x_move, y_move)
        print("\n")
        self.move(go[0],go[1])
    
    @classmethod
    def recStep(self, x_recmovestep, y_recmovestep, go):
        array = []
        array.append((x_recmovestep,y_recmovestep))
        array.append(self.checkMove(x_recmovestep,y_recmovestep))
        array.append(go)
        allfork = array[1]
        havemoved = array[2]
        print("remove",havemoved)
        if len(array) == 2:
            path.put(array)
        else:
            allfork.remove(havemoved)
            path.put(array)
    
    @classmethod
    def actStep(self,x_moved,y_moved):
        realpath.append((x_moved,y_moved))
        return realpath
        
    @classmethod
    def choose(self,x_fork,y_fork):
        ways = self.checkMove(x_fork,y_fork)
        choosefork= self.random(ways)
        if realpath.count(choosefork) >= 1:
            self.choose(x_fork,y_fork)
        else:
            return choosefork
    
    def setMaze(self,maze):
        self.maze_map = maze
        
    @classmethod
    def random(self,list):
        from random import choice
        return choice(list)
    
    @classmethod
    def checkGoal(self,x_goal,y_goal):
        maze = self.maze_map
        x_Mazeboun = len(maze[0])
        y_Mazeboun = len(maze)
        if maze[x_goal][y_Mazeboun-1] == 0 or maze[x_goal][0] ==0 or maze[0][y_goal] == 0 or maze[x_Mazeboun-1][y_goal] == 0:
            return True
        else:
            return False
        
    @classmethod
    def printMaze(self, maze_map):
        print("in maze")
        for row in maze_map:
            for val in row:
                print(val,end=" ")
            print(end="\n")

    

def main():
    maze =[
           [2, 2, 2, 2, 2, 2, 2],
           [2, 0, 0, 0, 0, 0, 2],
           [2, 0, 2, 0, 2, 0, 2],
           [2, 0, 0, 0, 0, 2, 2],
           [2, 2, 0, 2, 0, 2, 2],
           [2, 0, 0, 0, 0, 0, 0],
           [2, 2, 2, 2, 2, 2, 2]]

    m = MickeyMove(maze, 1,1)
    #print(m.maze_map)
    #m.printMaze(m.maze_map)
    m.getMaze(maze)
    m.move(1,1)
                
    
if __name__ == "__main__":
    main()
